<style>
@import url('https://fonts.googleapis.com/css2?family=Noto+Color+Emoji&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Google+Sans+Text:wght@400;500;700;900&display=swap');


:root {
	--grey-outline: #dddddd;
	--grey-background: #f7f7f7;
	--grey-inactive-label: grey;
	--blue-active: #0075ff;
	--grey-text-input: #ededf5;
	padding: 6px;
	font-family: "Google Sans Text", system-ui, sans-serif;
	font-size: 12px;
	background-color: var(--grey-background);
}

input {
	font-family: "Google Sans Text", system-ui, sans-serif;
	font-size: 14px;
}

.emoji-group-icon {
	font-family: "Material Symbols Outlined";
	font-weight: normal;
	font-style: normal;
	font-size: 24px;
	line-height: 1;
	letter-spacing: normal;
	text-transform: none;
	display: inline-block;
	white-space: nowrap;
	word-wrap: normal;
	direction: ltr;
	-webkit-font-feature-settings: 'liga';
	-webkit-font-smoothing: antialiased;
	color: var(--emoji-grey);
	font-variation-settings: 'FILL' 1;
	text-align: center;
}

.material-symbols {
	font-family: "Material Symbols Outlined";
}

/* section headings */
h2 {
	font-size: 20px;
	font-weight: bold;
	_text-transform: uppercase;
	padding-bottom: 2px;
	padding-top: 0;
	margin: 0;
}

h2.emoji-group {
	font-size: 11px;
	text-transform: uppercase;
	padding-top: 7px;
	padding-bottom: 7px;
}

/* text-transform: uppercase;
	font-weight: bold;
	font-size: 0.7em;
	margin-left: 0.4em; */


#intro {
	font-size: 0.75rem;
}

.controls-new {
	display: grid;
	grid-template-rows: auto auto 1fr auto auto;
	height: 100%;
}

.mode-select {
	display: grid;
	width: 100%;
	grid-template-columns: 50% 50%;
	font-size: 14px;
}

.mode {
	position: relative;
	text-align: center;
	border-bottom: 2px solid var(--blue-active);
	padding-bottom: 9px;
	cursor: default;
	user-select: none;
}

.icon {
	position: absolute;
	top: -4px;
	font-family: "Material Symbols Outlined";
	font-size: 20px;
	font-weight: normal;
	display: inline-block;  
	user-select: none;
}

.font .size {
	display: grid;
	width: 100%;
	align-items: center;
}

.font, .axis {
	display: grid;
	grid-template-columns: 70px 1fr;
	width: 100%;
	align-items: center;
}

.select {
	position: relative;
}

.dropdown {
	position: absolute;
	display: none;
	top: 1em;
	background-color: white;
	line-height: 1.5em;
	border: solid lightgrey;
	border-width: 0 1px 1px 1px;
	z-index: 10;
	padding: 0.3em;
}

.axis .tag {
	cursor: pointer;
}

.axis .numeric {
	width: 100%;
	_background-color: white;
	border: none;
}

.axis .slider {
	width: 100%;
	vertical-align: middle;
}

.style {
	grid-column: 1 / 3;
}

.icon-wrap {
  position: relative;
  padding-right: 2em;
}

.controls.emoji {
	_display: none;
	background-color: pink;
}

.font-select {
	display: grid;
	width: 100%;
	grid-template-columns: 15% 20px 1fr 20px;
	font-size: 12px;
	padding: 6px 0;
}

.font-select .icon {
	_position: relative;
	_top: 6px;
	_font-family: "Material Symbols Outlined";
	font-size: 24px;
	_padding-right: 5px;
}

.font-select .size {
	position: relative;
}

.font-select .font-family {
	position: relative;
}

.dropdown-icon {
	position: absolute;
	text-align: right;
}

.font-style {
	width: 100%;
}

.axes {

}

.palettes {

}

.common {
	display: grid;
	grid-template-columns: 50% 50%;
}

.button {
	border: 2px solid black;
	border-radius: 5em;
	padding: 10px;
	display: inline-block;
	font-size: 14px;
	width: 100%;
}

h2 { /* for Axes and Palettes headings */
	font-weight: bold;
	font-size: 14px;
	margin-top: 1.25em;
}

h3 { /* for emoji category */
	text-transform: uppercase;
	font-size: 11px;
}

.text-input {
	width: 100%;
}

.text-input input, .search input {
	width: 100%;
	background-color: var(--grey-text-input);
	border-radius: 5em;
	border: none;
	padding: 0.8em;
}

#controls {
	display: grid;
	width: 100%;
	grid-template-columns: 1fr 3fr;
	position: relative;
	row-gap: 7px;
}

.reveal {
	transform: rotate(-90deg);
	position: relative;
	transform-origin: center;
}

.reveal-open {
	transform: rotate(0deg);
}

#axes-header {
	display: none;
}

.palette {
	display: grid;
	width: 100%;
	grid-template-columns: 20px repeat(18, 1fr);
	column-gap: 2px;
	align-items: center;
}

.palette input[type=color] {
	width: 40px;
	height: 40px;
	padding: 0;
	border: none;
	position: absolute;
	left: -10px;
	top: -10px;
}

.palette .frame {
	width: 13px;
	height: 13px;
	border: 1px solid var(--grey-outline);
	position: relative;
	overflow: hidden;
}

#emoji-picker {
	_display: none;
	_width: 300px;
	width: 100%;
	height: 300px;
	grid-column: span 2;
	--emoji-grey: #606368;
	--selected: #2c54d0;
	--highlight: #edf3fe;
	box-sizing: border-box;
	border: 2px solid var(--emoji-grey);
	border-radius: 5px;
	position: relative;
}

#emoji-search {
	width: calc(100% - 2 * 0.3em);
	margin: 0.3em;
}

#emoji-type {
	display: grid;
	grid-template-columns: repeat(10, 1fr);
	margin-bottom: 0.3em;
	cursor: pointer;
}

#emoji-main {
	color: var(--emoji-grey);
}

#emoji-main label {
	text-transform: uppercase;
	font-weight: bold;
	font-size: 0.7em;
	margin-left: 0.4em;
}

.emoji-grid {
	width: 100%;
	display: grid;
	grid-template-columns: repeat(9, 1fr);  
	font-size: 25px;
	overflow-y: scroll;
	height: 221px;
	grid-auto-rows: 34px;
}

.emoji-cell {
	position: relative;
	text-align: center;
	cursor: pointer;
	overflow: hidden;
}

.selected {
	color: var(--selected);
}

.emoji-variants-grid {
	position: absolute;
	left: 0px;
	top: -1em;
	z-index: 1;
	background-color: white;
	border: 1px solid black;
	border-radius: 3px;
}	

</style>

<!-- <script type="module" src="./fontlist.js"></script> -->

<!-- <h2>figma-colrv1</h2> -->

<!-- NEW CONTROLS (start) -->
<div class="controls-new">

	<div class="mode-select">
		<div class="mode emoji"><span class="icon-wrap"><div class="icon">mood</div></span> Emoji</div>
		<div class="mode text"><span class="icon-wrap"><div class="icon">insert_text</div></span> Text</div>
	</div>

	<div class="controls text">

		<div class="font">

			<div class="size select">12px</div><div class="icon">arrow_drop_down</div>
	
			<div class="family select">Select font…</div>
	
			<div class="style select">Select style…</div>
	
		</div>
	
		<div class="axes">
			<h2><span class="icon-wrap"><div class="icon" style="top: -3px; font-size: 1.625em;">custom_typography</div></span> Axes</h2>
			<div class="axis-controls">
				<!-- <div class="axis"> -->
				<!-- <div class="axis"> -->
			</div>
		</div>

		<div class="palettes">
			<h2><span class="icon-wrap"><div class="icon">palette</div></span> Palettes</h2>
			<div class="palette-controls">
				<!-- <div class="palette"> -->
				<!-- <div class="palette"> -->
			</div>
		</div>

	</div>

	<!-- EMOJI CONTROLS start -->
	<div class="controls emoji">

		<div class="font">

			<div class="size select">12px</div><div class="icon">arrow_drop_down</div>
	
			<div class="family select">Select font…</div>
	
			<div class="style select">Select style…</div>
	
		</div>
	
		<div class="search">
			<input type="text" value="" placeholder="Search emoji">
		</div>

		<div id="emoji-picker" class="emoji-mode" style="border: 1px solid red; background-color: yellow;">
			<div id="emoji-type">
				<div class="emoji-group-icon">schedule</div>
				<div class="emoji-group-icon default">mood</div>
				<div class="emoji-group-icon">emoji_people</div>
				<div class="emoji-group-icon">emoji_nature</div>
				<div class="emoji-group-icon">emoji_food_beverage</div>
				<div class="emoji-group-icon">emoji_transportation</div>
				<div class="emoji-group-icon">emoji_events</div>
				<div class="emoji-group-icon">emoji_objects</div>
				<div class="emoji-group-icon">glyphs</div>
				<div class="emoji-group-icon">emoji_flags</div>
			</div>

			<h2 class="emoji-group">Heading</h2>		

			<div id="emoji-main">
				<div class="emoji-grid"></div>
				<div class="emoji-variants-grid"></div>
			</div>		
		</div>
	

	</div>
	<!-- EMOJI CONTROLS end -->

	<!-- TEXT CONTROLS start -->
	<div class="text-input" style="border-top: 1px solid #ddd; padding-top: 12px;">
		<input type="text" value="" placeholder="Text will update as you type">
	</div>

	<div class="common" style="padding-top: 14px;">
		<div>
			<span class="icon-wrap"><div class="icon" style="font-size: 24px; padding-top: 12px;">info</div></span>
		</div>

		<div style="margin: 0 -4px 0 20px;">
			<button class="button" style="margin-bottom: -4px;">
				<span class="icon-wrap"><div class="icon">code</div></span>
				<span>Show CSS</span>
			</button>
		</div>
		
	</div>
	<!-- TEXT CONTROLS end -->

	<div id="css"></div>
	

</div>

<!-- NEW CONTROLS (end) -->


</div>
<!-- <script type="module" src="dist/fontlist.js"></script> -->

<script type="module">

function EL(el) {

}


const GLOBAL = {
	emojiSVGs: {}, // store all the svgs: should be emptied on font change
	emojiVariants: {}, // string keys indexing an array of variant strings (key is only present if there are variant strings, so no empty arrays)
	emojiVariantsDelay: 650, // ms
	emojiGroupLookup: { // these property names are strings that GSUB to icons from Material Symbols
		schedule: -1,
		mood: 0,
		emoji_people: 1,
		emoji_nature: 2,
		emoji_food_beverage: 3,
		emoji_transportation: 4,
		emoji_events: 5,
		emoji_objects: 6,
		glyphs: 7,
		emoji_flags: 8,
	},
	emojiPickerUsesSystemFont: false,
	uiReady: true,
	fontList: [],
};

// run this when the UI is ready
(function initUI() {
	populateAxes();
	populatePalettes();
	setMode();

	switchFontFamily();
	
})();


function fontByName(name) {
	return GLOBAL.fontList.find(font => name && font.name === name);
}

function switchFontFamily(e) {

	const family = e ? e.target.textContent : "Noto Color Emoji";

	const font = fontByName(family);
	
	console.log("switching font family to ", family)
	parent.postMessage({ pluginMessage: { type: 'fetch-font-by-name', name: family } }, "*");

	// hide the dropdown menu
	if (e)
 		document.querySelector(".font .family.select .dropdown").style.display = "none";

}

function populateSelects() {

	const familySelectEmojiEl = document.querySelector(".controls.emoji .font .family.select");
	const familySelectTextEl = document.querySelector(".controls.text .font .family.select");


	// add a dropdown div to each select element
	document.querySelectorAll(".select").forEach(selectEl => {
		const dropdownEl = document.createElement("div");
		dropdownEl.classList.add("dropdown");

		selectEl.append(dropdownEl);
		selectEl.onclick = openSelect;

	});

	// populate font families
	GLOBAL.fontList.forEach((font, f) => {
		const familyEl = document.createElement("div");
		familyEl.classList.add("dropdown-item")
		familyEl.innerText = font.name;
		familyEl.onclick = switchFontFamily;
		const familySelectEl = font.attributes.includes("text") ? familySelectTextEl : familySelectEmojiEl;
		familySelectEl.querySelector(".dropdown").append(familyEl);
	});

}

function openSelect(e) {

	const dropDownEl = e.target.querySelector(".dropdown");
	if (dropDownEl) {
		dropDownEl.style.display = dropDownEl.style.display === "block" ? "none" : "block";
	}
}

function populateAxes() {

	console.log("populateAxes()")
	const axisControlsEl = document.querySelector(".axes .axis-controls");
	if (!GLOBAL.fvar || !GLOBAL.fvar.axes || GLOBAL.fvar.axes.length === 0) {
		axisControlsEl.innerHTML = "No variation axes found.";
	}
	else {
		axisControlsEl.innerHTML = "";
		GLOBAL.fvar.axes.forEach(axis => {
			const value = axisDefaultOverride(axis);
			const axisEl = document.createElement("div");
			axisEl.style.width = "100%";
			const leftEl = document.createElement("div");
			const rightEl = document.createElement("div");

			const tagEl = document.createElement("div");
			tagEl.textContent = axis.axisTag;
			tagEl.title = axis.name;
			tagEl.classList.add("tag");

			const numericEl = document.createElement("input");
			numericEl.type = "text";
			numericEl.value = value;
			numericEl.classList.add("numeric");
			numericEl.style.fontFamily = "Google Sans Text";

			console.log(numericEl.value);
			numericEl.disabled = true;
			numericEl.style.textAlign = "left";

			const sliderEl = document.createElement("input");
			sliderEl.type = "range";
			sliderEl.classList.add("slider");
			sliderEl.min = axis.minValue;
			sliderEl.max = axis.maxValue;
			sliderEl.value = value;
			//sliderEl.style.verticalAlign = "middle";
			sliderEl.oninput = axisInput;

			leftEl.append(tagEl, numericEl);
			rightEl.append(sliderEl);
			axisEl.append(leftEl, rightEl);
			axisEl.classList.add("axis");
			axisControlsEl.append(axisEl);
		});
	}
}

function clamp(value, min, max) {
	return Math.min(Math.max(value, min), max);
}

function axisDefaultOverride(axis) {
	const overrides = {
		wdth: 100,
		wght: 400,
		ital: 0,
		opsz: 12,
	};

	if (overrides[axis.axisTag] !== undefined) {
		return clamp(overrides[axis.axisTag], axis.minValue, axis.maxValue);
	}
	else {
		return axis.defaultValue;
	}
}

function populatePalettes() {

	console.log("populatePalettes()")
	const palettesEl = document.querySelector(".palettes .palette-controls");
	console.log(palettesEl);
	console.log(GLOBAL.CPAL);
	if (!GLOBAL.CPAL || !GLOBAL.CPAL.palettes || GLOBAL.CPAL.palettes.length === 0) {
		palettesEl.innerHTML = "No CPAL palettes found.";
	}
	else {
		palettesEl.innerHTML = "";
		GLOBAL.CPAL.palettes.forEach((palette, p) => {

			// list: each palette div needs n children for the grid to work
			const paletteEl = document.createElement("div");
			paletteEl.classList.add("palette");

			// create each radio button
			const radio = document.createElement("input");
			radio.type = "radio";
			radio.name = "palette-id";
			radio.value = p;
			paletteEl.append(radio);
			if (p==0) {
				radio.checked = true;
			}

			// EVENT: switch palette
			radio.onchange = updateRendering;

			// create the color inputs
			palette.colors.forEach((color, c) => {
				const frame = document.createElement("div");
				frame.classList.add("frame");
				const sample = document.createElement("input");
				sample.type = "color";
				sample.value = GLOBAL.CPAL.hexColors[color];
				sample.dataset.paletteId = p;
				sample.dataset.entryId = c;
				if (c < 18) { // TODO: hack to show max 18 colors in a palette
					frame.append(sample);
					paletteEl.append(frame);

					// EVENT: edit color in palette
					sample.oninput = editColor;
				}
				sample.title = `Palette ${p}, entry ${c}: ${GLOBAL.CPAL.hexColors[color]}`;
			});
			palettesEl.append(paletteEl);
		});
	}
}

function setMode(e) {

	//alert ("mode clicked")
	const el = e ? e.target : document.querySelector(".mode");

	// flip the underline that denotes the selected mode
	el.parentNode.querySelectorAll(".mode").forEach(el_ => el_.style.borderColor = (el === el_) ? "var(--blue-active)" : "transparent" ); // reset all to transparent
	//el.style.borderColor = ;

	console.log(GLOBAL.fvar)
	
	// show/hide the relevant controls
	console.log('in setmode()');
	console.log(el);

	GLOBAL.mode = "";
	if (el.classList.contains("emoji")) {
		document.querySelector(".controls.emoji").style.display = "block";
		document.querySelector(".controls.text").style.display = "none";
		document.querySelector(".text-input input").placeholder = "Emoji will insert as you select";
		document.querySelector(".text-input input").style.fontFamily = "Noto Color Emoji,Google Sans Text";
		GLOBAL.mode = "emoji";
	}
	else if (el.classList.contains("text")) {
		document.querySelector(".controls.text").style.display = "block";
		document.querySelector(".controls.emoji").style.display = "none";
		document.querySelector(".text-input input").placeholder = "Text will update as you type";
		document.querySelector(".text-input input").style.fontFamily = "Google Sans Text";
		GLOBAL.mode = "text";
	}

	document.querySelector(".text-input input").value = "";

}

function axisInput(e) {
	const input = e.target;
	const numericEl = e.target.closest(".axis").querySelector(".numeric");
	numericEl.value = e.target.value;

	// document.querySelector("#instances-select").value = "-2";

	// TODO: set all other axes that have this tag to this new value
	updateRendering();
}


// EVENT: change mode text/emoji
document.querySelectorAll(".mode").forEach(el => {
	el.onclick = setMode;
});

// EVENT: type text into the text box
document.querySelector(".text-input input").oninput = updateRendering;




function axisValues() {
	const fvs = {};
	const axisEls = document.querySelectorAll(`.axis-controls .axis`);
	if (GLOBAL?.fvar?.axes.length && axisEls.length === GLOBAL.fvar.axes.length) {
		GLOBAL.fvar.axes.forEach((axis, a) => fvs[axis.axisTag] = parseFloat(axisEls[a].querySelector(".numeric").value) );
	}
	return fvs;
}

function changedAxisInput(e) {
	const input = e.target;
	const other = input.parentNode.querySelector(`input[type=${ input.type == "range" ? "text" : "range"} ]`);
	other.value = input.value;
	document.querySelector("#instances-select").value = "-2";

	// TODO: set all other axes that have this tag to this new value
	updateRendering();
}

function changedInstance(e) {

	const selection = parseInt(e.target.value);
	if (selection >= -1) { // default (-1) and the named instances (0 to instances.length-1)
		document.querySelectorAll(".axis").forEach((axisDiv, a) => {
			let coord;
			if (selection == -1) {
				coord = GLOBAL.fvar.axes[a].defaultValue;
			}
			else {
				const instance = GLOBAL.fvar.instances[selection];
				coord = instance.coordinates[a];
			}
			axisDiv.querySelectorAll("input").forEach(input => input.value = coord); // does the input[type=text] and the input[type=range]
		});
		updateRendering();
	}
	else if (selection == -2) { // custom instance
		console.log("Custom"); // no action needed, maybe alert the user to try the sliders
	}
}

function updateRendering(figmaNodeId) {

	const options = {
		fvs: axisValues(),
		text: document.querySelector(".text-input input").value,
		fontSize: parseFloat(document.querySelector(".size.select").textContent), // the numeric (text) input is the source of truth
	}
	if (GLOBAL.CPAL) {
		const paletteEl = document.querySelector(`input[name="palette-id"]:checked`);
		if (paletteEl) {
			options.paletteId = paletteEl.value;
		}
	}
	parent.postMessage({ pluginMessage: { type: 'render', options: options } }, '*');

	// update CSS for user to copy
	let css = "@font-face {\n\tfont-family: \"" + GLOBAL.fontFamily + "\";\n\tsrc: url(\"" + GLOBAL.fontURL + "\");\n}\n\n";
	css += ".myClass {\nfont-family: \"" + GLOBAL.fontFamily + "\";\n\n}\n"

	document.querySelector("#css").value = css;
}

function changeMode(e) {

	GLOBAL.mode = e.target.textContent.toLowerCase();

	// disable/enable the relevant UI items
	document.querySelectorAll(".text-mode").forEach(el => {
		el.style.display = GLOBAL.mode === "text" ? "block" : "none";
	});
	document.querySelectorAll(".emoji-mode").forEach(el => {
		el.style.display = GLOBAL.mode === "emoji" ? "block" : "none";
	});

	// update the mode picker ui to show which is selected
	document.querySelectorAll("#mode span").forEach(span => {
		if (span === e.target) {
			span.style.fontWeight = "700";
		}
		else {
			span.style.fontWeight = "400";
		}
	});

	// empty the text input box
	const textEl = document.querySelector("#text");
	textEl.value = "";
	textEl.setAttribute("placeholder", GLOBAL.mode === "emoji" ? "your emoji" : "your text");


	// populate emoji picker
	if (GLOBAL.mode === "emoji") {

		// fetch the emoji font
		// - response will be handled in "font-fetched" and "emoji-svgs" messages
		parent.postMessage({ pluginMessage: {
			type: 'fetch-font-by-name',
			name: "Noto Color Emoji",
			excludes: ["CPAL"], // we don’t need CPAL data in the UI
		} }, "*");

	}
}

// handle mode change text/emoji
document.querySelectorAll("#mode span").forEach(span => {
	span.onclick = changeMode;
});


function editColor(e) {
	const message = {
		type: "palette-edit",
		paletteId: e.target.dataset.paletteId,
		entryId: e.target.dataset.entryId,
		color: e.target.value,
	}
	parent.postMessage({ pluginMessage: message }, "*");
	updateRendering();
}

document.querySelectorAll(".font-size input").forEach(input => {

	// this one only sends the "input" event if the UI is ready
	function updateFontSizePlease(e) {
		if (GLOBAL.uiReady) {
			GLOBAL.uiReady = false;
			updateFontSize(e);
		} 
	}

	function updateFontSize(e) {
		const input = e.target;
		const log2min = Math.log2(4);
		const log2max = Math.log2(200);
		const scale = "log"; // or "linear"
		const sibling = input.parentNode.querySelector(`input[type=${ input.type == "text" ? "range" : "text"}]`); // get the "other" input

		if (scale == "log") {
			if (input.type == "text") {
				// convert from linear to log2 for the input[type=range]
				const fontSize = parseFloat(input.value);
				const log2 = Math.log2(fontSize);
				const posOnLogScale = (log2 - log2min)/(log2max - log2min);
				sibling.value = posOnLogScale;
			}
			else {
				// convert from log2 to linear for the input[type=text]
				const posOnLogScale = parseFloat(input.value);
				const log2 = log2min + posOnLogScale * (log2max - log2min);
				const fontSize = (Math.pow(2, log2)).toFixed(2);
				sibling.value = fontSize;
			}
		}
		else { // scale == "linear"
			// we also need to use the linear min and max, not the 0 and 1 of the log method
			sibling.value = input.value;
		}

		updateRendering();
	}
	input.oninput = updateFontSizePlease;
	input.onchange = updateFontSize;
});

// add event so we change group when we click on a group icon
document.querySelectorAll(".emoji-group-icon").forEach(el => {
	el.onclick = emojiChangeGroup;
});


// drag-drop a font file [NEW]
// - assume all drag-drop fonts are text fonts, not emoji
document.querySelector(".controls-new").ondragover = e => {
	e.preventDefault();
};

document.querySelector(".controls-new").ondrop = e => {
	e.preventDefault();

	const file = e.dataTransfer.files[0];
	file.arrayBuffer().then(arrayBuffer => {
		
		// send this data to the plugin as base64
		let uint8 = new Uint8Array(arrayBuffer);
		let str = "";
		for (let i=0; i<arrayBuffer.byteLength; i++) {
			str += String.fromCharCode(uint8[i]);
		}

		const message = {
			type: "font-upload",
			// fontData: btoa(String.fromCharCode(...new Uint8Array(arrayBuffer))), // this works for short blobs but gives error "Maximum call stack size exceeded" for longer ones, hence the for loop above
			fontData: btoa(str), // base64 encoding of the ArrayBuffer
		}
		parent.postMessage({ pluginMessage: message }, "*");
	});

};



// receive messages from the plugin code
// https://www.figma.com/plugin-docs/creating-ui
onmessage = (e) => {
	console.log("UI received message");

	const msg = e.data.pluginMessage;
	console.log(msg);

	switch (msg.type) {

		case "init": {
			console.log("Got init message");
			console.log(msg);
			break;
		}

		case "names": {
			console.log("names switch");
			alert ("names")

			break;
		}

		case "font-list": {
			GLOBAL.fontList.push(...msg.fontList);
			populateSelects();
			break;
		}

		case "render-complete": {
			GLOBAL.uiReady = true;
			break;
		}

		case "emoji-ordering": {
			GLOBAL.emojiMetadata = msg.emojiMetadata;

			// set up emoji ordering
			GLOBAL.emojiVariants = {};
			GLOBAL.emojiMetadata.forEach(emojiGroup => {
				emojiGroup.emoji.forEach(emojiChar => {
					if (emojiChar.alternates.length > 0) {
						const str = String.fromCodePoint(...emojiChar.base);
						GLOBAL.emojiVariants[str] = [];
						emojiChar.alternates.forEach(variant => {
							GLOBAL.emojiVariants[str].push(String.fromCodePoint(...variant));
						});
					}
				});
			});
			break;
		}

		case "font-fetched": {
			console.log("Font fetched");

			GLOBAL.fvar = undefined;
			GLOBAL.CPAL = undefined;

			// we can prepare the UI now

			// emoji handling: we need to import the emoji glyphs to show in the picker
			// - the response will be handled in onmessage for "emoji-svgs"
			if (GLOBAL.mode === "emoji") {
				document.querySelector(".emoji-group-icon.default").dispatchEvent(new Event("click")); // trigger a fetch of the default emoji group
			}

			break;
		}

		case "font-data-delivered": {
			updateRendering(); // update the text being edited to this font

			// new
			populateAxes();
			populatePalettes();

			console.log("msg.fontFamily");
			console.log(msg.fontFamily);
			GLOBAL.fontFamily = msg.fontFamily;
			GLOBAL.fontMetadata = GLOBAL.fontList.find(font => font.name === GLOBAL.fontFamily);
			
			if (GLOBAL.fontMetadata.attributes.includes("emoji")) {
				GLOBAL.mode = "emoji";
			}
			else if (GLOBAL.fontMetadata.attributes.includes("text")) {
				GLOBAL.mode = "text";
			}
			else {
				GLOBAL.mode = "";
			}
			
			if (GLOBAL.mode !== "") {
				document.querySelector(`.mode.${GLOBAL.mode}`).dispatchEvent(new Event("click")); // trigger a fetch of the text emoji mode
			}

			break;
		}

		case "fvar": {
			// build axes list
			GLOBAL.fvar = msg.fvar;
			if (GLOBAL.fvar?.axes) {
				GLOBAL.fvar.axes.forEach(axis => {
					const axisDiv = document.createElement("div");
					axisDiv.classList.add("axis");

					const tag = document.createElement("label");
					tag.textContent = axis.axisTag;
					tag.title = axis.name;

					const numeric = document.createElement("input");
					numeric.type = "text";
					numeric.value = axis.defaultValue;
					numeric.oninput = changedAxisInput;

					const slider = document.createElement("input");
					slider.type = "range";
					slider.min = axis.minValue;
					slider.max = axis.maxValue;
					slider.value = axis.defaultValue;
					slider.step = 0.01;
					slider.oninput = changedAxisInput;

					axisDiv.append(tag, numeric, slider);
					axesList.append(axisDiv);

				});
			}

			break;
		}

		case "CPAL": {
			GLOBAL.CPAL = msg.CPAL;
			break;
		}

		case "emoji-svgs": {

			// now place all the default svgs in the panel
			if (msg.emojiType >= 0 && msg.emojiType < GLOBAL.emojiMetadata.length) {
				const emojiGrid = document.querySelector("#emoji-main .emoji-grid");
				const emojiGroup = GLOBAL.emojiMetadata[msg.emojiType]; // 0-based index into the defined groups
				Object.assign(GLOBAL.emojiSVGs, msg.svgs); // merge new svgs with existing svgs (we could check this array in advance, since the svgs may be cached already)
				emojiGrid.innerHTML = "";
				emojiGroup.emoji.forEach(emojiChar => {
					const str = String.fromCodePoint(...emojiChar.base); // get the string we need
					emojiInsertIntoContainer(emojiGrid, str, msg.svgs[str]);
				});
			}
			else {
				console.log("Error: emojiType out of range");
			}
			break;
		}
	}
}


function emojiInsertIntoContainer(container, str, svg, variant=false) {

	const el = document.createElement("div");
	el.classList.add("emoji-cell");
	el.innerHTML = svg;
	el.dataset.string = str;

	container.append(el);

	// handle long-click if it’s a default emoji or mouseup if it’s a variant emoji
	if (variant) {
		el.onmouseup = emojiPick;
	}
	else {
		el.onmousedown = emojiVariantTimer;
		el.onclick = emojiPick;
	}
}

function emojiPick(e) {
	const el = e.target.closest(".emoji-cell"); // which cell did we click on?
	const inputEl = document.querySelector(".text-input input")
	inputEl.value += el.dataset.string; // append the selected emoji (as a string) to the input text
	inputEl.dispatchEvent(new Event("input")); // trigger a redraw by sending the "input" event to the <input id="#text"> element
}

function emojiVariantTimer(e) {
  
  const el = e.target.closest(".emoji-cell");
  const str = el.dataset.string;

  // are there in fact any alternates for this string?
  if (GLOBAL.emojiVariants[str]) {

		// start timer and define what happens when it times out
		GLOBAL.emojiVariantsTimer = setTimeout(function () {

			const emojiGrid = el.closest(".emoji-grid"); // we need this for its scroll offset
			const elVariants = document.querySelector(".emoji-variants-grid");
			elVariants.style.display = "grid";
			elVariants.innerHTML = ""; // clear previous alternates
			const itemsPerRow = Math.min(5, GLOBAL.emojiVariants[str].length);
			elVariants.style.display = "grid";
			elVariants.style.gridTemplateColumns = `repeat(${itemsPerRow}, 1fr)`;
			elVariants.style.gridAutoRows = "34px";
			elVariants.style.left = `${el.offsetLeft}px`;
			elVariants.style.top = `${el.offsetTop - 34 - emojiGrid.scrollTop}px`;
			elVariants.style.width = (itemsPerRow * 27) + `px`;
			GLOBAL.emojiVariants[str].forEach(variantStr => emojiInsertIntoContainer(elVariants, variantStr, GLOBAL.emojiSVGs[variantStr], true) );
			GLOBAL.emojiVariantsTimer = null;

		}, GLOBAL.emojiVariantsDelay);

		document.onmouseup = clearLongpressTimer; // cancel timer if the mouseup happens at document level
	}
}

function clearLongpressTimer(e) {
	clearTimeout(GLOBAL.alternatesTimer);
	GLOBAL.emojiVariantsTimer = null;
	document.removeEventListener("onmouseup", clearLongpressTimer);

	// hide the alternates picker
	const elVariants = document.querySelector(".emoji-variants-grid");
	elVariants.style.display = "none";
}

// change emoji group
function emojiChangeGroup(e) {
	const el = e.target;
	const emojiGroupId = GLOBAL.emojiGroupLookup[el.textContent]; // an integer index into the emojiMetadata array

	// reset scroll position
	const emojiGrid = document.querySelector(".emoji-grid");
	emojiGrid.scrollTop = "0px";

	// fetch emojis for the requested group
	// - the response will be a message of type "emoji-svgs", with string keys and svg values
	const message = { type: "fetch-emojis", emojiType: emojiGroupId };
	parent.postMessage({ pluginMessage: message }, "*");

	// set the group title
	document.querySelector("h2.emoji-group").innerText = GLOBAL.emojiMetadata[emojiGroupId].group;

	// update icon color/style
	document.querySelectorAll(".emoji-group-icon").forEach(el_ => {
		if (el_ === el) {
			el_.style.textDecoration = "underline";
			el_.classList.add("selected");
		}
		else {
			el_.style.textDecoration = "none";
			el_.classList.remove("selected");
		}
	});
}


</script>
